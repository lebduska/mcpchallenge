# MCP Challenge â€“ Design Rules

## ðŸŽ¯ Core philosophy

This is not a game platform.
This is an interactive playground for experiments, learning and AI-driven simulations.

Games are just friendly interfaces for systems.

Design should feel like:
ðŸ§ª a lab
ðŸŽ› a simulator
ðŸŽ¨ a creative sandbox

Not like:
ðŸŽ® an arcade
ðŸ“± a mobile game
ðŸŽ‰ a casino

---

## ðŸ–¼ Visual hierarchy

1. The WORLD (canvas, board, simulation) is always the hero.
2. UI supports experimentation â€” never steals attention.
3. Controls feel like tools, not toys.

---

## ðŸŽ› Controls & interaction

Prefer:
â€¢ sliders
â€¢ knobs
â€¢ dials
â€¢ subtle buttons

Avoid:
â€¢ huge CTA buttons
â€¢ flashing animations
â€¢ gamified popups

Controls should feel:
"adjust parameters and observe results"

---

## ðŸŒˆ Visual style

Use:
â€¢ soft gradients
â€¢ depth and subtle shadows
â€¢ rounded surfaces
â€¢ calm colors
â€¢ motion only when informative

Avoid:
â€¢ neon colors
â€¢ heavy glow
â€¢ aggressive animations
â€¢ visual noise

---

## ðŸ“ˆ Feedback & progress

Show:
â€¢ iterations
â€¢ attempts
â€¢ improvement
â€¢ history
â€¢ trajectories
â€¢ states

Prefer:
"Try â†’ observe â†’ refine"

Over:
"Win â†’ lose â†’ restart"

---

## ðŸ§  Emotional tone

Encourage curiosity, not pressure.

Feels like:
"I'm exploring something interesting"

Not:
"I must beat this level"

---

## ðŸ§© MCP & advanced tools

Technical elements should:

â€¢ be hidden by default
â€¢ live in "Advanced mode"
â€¢ feel optional and powerful

Never block fun or exploration.

---

## ðŸ“± UI consistency

Across all challenges:

âœ” same layout logic
âœ” same spacing rhythm
âœ” same control patterns
âœ” same feedback language

Each challenge can have unique visuals,
but must follow the same interaction philosophy.

---

## âœ… Design test (ask before shipping anything)

If you squint your eyes and hide text:

Does it look like a calm interactive system â€” or a mobile game?

If it feels like a game â†’ simplify.
If it feels like a playground â†’ ship it.

---

## ðŸ§  Think order

1. System / world first
2. Interaction second
3. UI last

Never the other way around.
